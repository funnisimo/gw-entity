!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("gw-map"),require("gw-utils")):"function"==typeof define&&define.amd?define(["exports","gw-map","gw-utils"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).GWE={},t.GWM,t.GWU)}(this,(function(t,e,s){"use strict";function i(t){if(t&&t.__esModule)return t;var e=Object.create(null);return t&&Object.keys(t).forEach((function(s){if("default"!==s){var i=Object.getOwnPropertyDescriptor(t,s);Object.defineProperty(e,s,i.get?i:{enumerable:!0,get:function(){return t[s]}})}})),e.default=t,Object.freeze(e)}var n=i(e),a=i(s);class r extends n.item.Item{constructor(t){super(t)}getAction(t){return this.kind.actions[t]}}class h extends n.item.ItemKind{constructor(t){super(t),this.actions={},t.actions&&Object.entries(t.actions).forEach((([t,e])=>{this.actions[t]=e}))}make(t){const e=new r(this);return this.init(e,t),e}}var u=Object.freeze({__proto__:null,ItemKind:h,Item:r});class o{constructor(t=[]){this._msgs=[],t.forEach((t=>this.add(t)))}add(t){return this._msgs.push(t),this}get(t,e=!0){const s=a.clamp(Math.floor(t*this._msgs.length),0,this._msgs.length-1),i=this._msgs[s];return this._format(i,e)}_format(t,e=!0){return t.replace(/\[(\w+)\|?(\w*)\]/g,e?"$1":"$2")}}const l={};class c{constructor(t={}){this._max={},this._rate={},this._value={},this.init(t)}get(t){return this._value[t]}max(t){return this._max[t]||0}regen(t){return this._rate[t]||null}init(t){for(let e in t)this.set(e,t[e])}set(t,e,s){if("number"!=typeof e){e=a.range.make(e).value()}this._value[t]=e,this._max[t]=s||e}gain(t,e,s=!1){"number"!=typeof e&&(e=a.range.value(e));let i=this._value[t]+e;s||(i=Math.min(i,this._max[t])),this._value[t]=i}drain(t,e){"number"!=typeof e&&(e=a.range.value(e)),this._value[t]=Math.max(0,this._value[t]-e)}raiseMax(t,e,s=!0){"number"!=typeof e&&(e=a.range.value(e)),this._max[t]+=e,s&&this.gain(t,e)}reduceMax(t,e,s=!1){"number"!=typeof e&&(e=a.range.value(e)),this._max[t]=Math.max(0,this._max[t]-e),s&&this.drain(t,e)}setRegen(t,e,s=1){const i=this._rate[t]=this._rate[t]||{elapsed:0};i.turns=e,i.count=s}regenAll(){for(let t in this._max){const e=this._rate[t];e.elapsed+=1,e.elapsed>=e.turns&&(this.gain(t,e.count),e.elapsed-=e.turns)}}restore(t,e){void 0===e&&(e=this._max[t]),this._value[t]=e}adjust(t,e,s){const i=(s=a.range.from(s)).value(),n=this.get(t);if("inc"===e)this.gain(t,s);else if("dec"===e)this.drain(t,s);else if("set"===e)this.set(t,s);else if("min"===e){const e=s.value();this.get(t)<e&&this.set(t,e)}else{if("max"!==e)throw new Error("Invalid stat adjust type: "+e);this.get(t)>i&&this.set(t,i)}return n!==this.get(t)}}class _{constructor(){this._set={},this._time={},this._count={},this._done={},this._value={},this.changed=null}clear(t){return this.clearTime(t),this.clearCount(t),this.setOff(t),this._update(t)}get(t){return this._value[t]||!1}has(t){return this._value[t]||!1}_addDone(t,e){e&&(this._done[t]||(this._done[t]=e))}setCount(t,e,s){return this._count[t]=Math.max(e,this._count[t]||0),this._addDone(t,s),this._update(t)}increment(t,e=1,s){"function"==typeof e&&(s=e,e=1);return this._count[t]=(this._count[t]||0)+e,this._addDone(t,s),this._update(t)}decrement(t,e=1){return this._count[t]=Math.max(0,(this._count[t]||0)-e),this._update(t)}clearCount(t){return this._count[t]=0,this._update(t)}setOn(t,e){return this._set[t]=!0,this._addDone(t,e),this._update(t)}setOff(t){return this._set[t]=!1,this._update(t)}setTime(t,e,s){e=a.range.make(e).value();const i=this._time[t]||0;return this._time[t]=Math.max(e,i),this._addDone(t,s),this._update(t)}addTime(t,e=1,s){"function"==typeof e&&(s=e,e=1);return e=a.range.make(e).value(),this._time[t]=(this._time[t]||0)+e,this._addDone(t,s),this._update(t)}removeTime(t,e=1){return e=a.range.make(e).value(),this._time[t]=Math.max(0,(this._time[t]||0)-e),this._update(t)}clearTime(t){return this._time[t]=0,this._update(t)}decayAllTimes(t=1){const e=this,s={};let i=!1;for(let n in e._time)this.removeTime(n,t)&&(i=!0,s[n]=!1);return!!i&&s}_update(t){const e=this,s=this._value;let i=s[t],n=s[t]=e._set[t]||e._time[t]>0||e._count[t]>0||!1;const a=this._done[t];return!n&&a&&(a(this,t),e._done[t]=null),(i&&!n||!(i||!n))&&(this.changed&&this.changed(this,t),!0)}}class d extends n.actor.Actor{constructor(t){super(t),this.stats=new c,this.status=new _}avoidsItem(t){return!1}canAddItem(t){return!1}addItem(t){}async act(){return!0}}class m extends n.actor.ActorKind{constructor(t){super(t),this.stats=t.stats||{}}make(t){const e=new d(this);return this.init(e,t),e}init(t,e={}){super.init(t,e),t.stats.init(this.stats)}}var f=Object.freeze({__proto__:null,PainMessages:o,painMessages:l,installPain:function(t,e){Array.isArray(e)&&(e=new o(e)),l[t]=e},getPain:function(t){const e=l[t];if(!e)throw new Error("No such pain message index: "+t);return e},Stats:c,Status:_,ActorKind:m,Actor:d});class p{constructor(t){this._base={},this._max={},this._bonus={},this._sustain={},this._value={},this.changed=null,this.init(t)}init(t){for(let e in g){const s="number"==typeof t?t:g[e];this.set(e,s)}if("number"!=typeof t)for(let e in t)this.set(e,t[e])}forEach(t){Object.keys(g).forEach((e=>t(this.get(e))))}get(t){return this._value[t]||0}set(t,e=0){return this._value[t]=e,this._base[t]=e,this._max[t]=e,this._bonus[t]=[],e}base(t){return this._base[t]||0}max(t){return this._max[t]||0}sustain(t){return this._sustain[t]||!1}gain(t,e,s=!0){if(e<0&&this._sustain[t])return 0;this._base[t]+=e,s&&this._base[t]>this._max[t]&&(this._max[t]=this._base[t]);let i=this.get(t);return this._calcValue(t)-i}drain(t,e,s=!1){e<0&&(e=-e);const i=this.gain(t,-e,!1);return i&&s&&(this._max[t]=this._base[t]),i}restore(t){this._base[t]=this._max[t];let e=this.get(t);return this._calcValue(t)-e}addBonus(t,e){return this._addBonus(t,{bonus:e})}_addBonus(t,e){"number"==typeof e&&(e={bonus:e}),void 0===this._value[t]&&this.set(t,0),this._bonus[t].push(e);let s=this.get(t);return this._calcValue(t)-s}clearBonus(t,e){return this._clearBonus(t,{bonus:e})}_clearBonus(t,e){"number"==typeof e&&(e={bonus:e});let s=this._bonus[t]||[],i=JSON.stringify(e),n=s.findIndex((t=>JSON.stringify(t)==i));if(n>-1){s.splice(n,1);let e=this.get(t);return this._calcValue(t)-e}return 0}_calcValue(t){let e={};this._bonus[t].forEach((t=>this._applyAdjustment(e,t))),this._sustain[t]=e.sustain||!1;let s=this._base[t]||0;return void 0!==e.fixed?s=e.fixed:(s+=e.bonus||0,void 0!==e.min&&(s=Math.max(e.min,s)),void 0!==e.max&&(s=Math.min(e.max,s))),this._value[t]=s}adjust(t,e){let s;return"number"==typeof e&&(e={bonus:e}),e.base?s=this.gain(t,e.base):e.restore?(s=this.restore(t),0==s&&(s=void 0)):s=this._addBonus(t,e),this.changed&&void 0!==s&&this.changed(this,t),s}clearAdjustment(t,e){let s;return"number"==typeof e&&(e={bonus:e}),e.base?s=this.drain(t,e.base,!0):e.restore||(s=this._clearBonus(t,e)),this.changed&&void 0!==s&&this.changed(this,t),s}_applyAdjustment(t,e){e.bonus&&(t.bonus=(t.bonus||0)+e.bonus),void 0!==e.fixed&&(t.fixed=Math.max(t.fixed||0,e.fixed)),void 0!==e.min&&(t.min=Math.max(t.min||0,e.min)),void 0!==e.max&&(t.max=Math.max(t.max||0,e.max)),void 0!==e.sustain&&(t.sustain=e.sustain)}}const g={};class b{constructor(t){this.name=t}get has(){return this._bool("_has")}get level(){return this._int("_level")}get disadvantage(){return this._bool("_disadvantage")}get advantage(){return this._bool("_advantage")}get fixed(){return this._int("_fixed")}get bonus(){const t=this._int("_bonus")||0;return this._parent?t+this._parent.bonus:t}get succeed(){return this._bool("_succeed")}get fail(){return this._bool("_fail")}set(t){!1===t?(this._has=!1,this._level=0):(this._has=!0,this._level=!0===t?0:t)}_value(t){return void 0!==this[t]?this[t]:this._parent?this._parent._value(t):void 0}_bool(t){return!!this._value(t)}_int(t){return this._value(t)}adjust(t){Object.entries(t).forEach((([t,e])=>{if(t="_"+t,void 0!==e){if("_fixed"===t){if("number"!=typeof e)throw new Error("fixed skill adjustment must be a number.");e=Math.max(e,this._fixed||0)}else if("_bonus"===t){if("number"!=typeof e)throw new Error("fixed skill adjustment must be a number.");e+=this._bonus||0}this[t]=e}}))}clear(t){Object.keys(t).forEach((t=>{void 0!==this[t="_"+t]&&(this[t]=void 0)}))}}class v{constructor(t={}){this._skills={},Object.entries(t).forEach((([t,e])=>{this.set(t,e)}))}set(t,e){const s=this.get(t);return s.set(e),s}get(t){let e=this._skills[t];if(e)return e;e=this._skills[t]=new b(t);const s=t.lastIndexOf(".");return s>0?e._parent=this.get(t.substring(0,s)):e.set(!1),e}adjust(t,e){"number"==typeof e&&(e={bonus:e});let s=this.get(t);return s.adjust(e),s}}class y extends d{constructor(t){super(t)}}y.default={ch:"@",fg:"white",name:"You"};class x extends m{constructor(t={}){super((t.sprite||(t.ch=t.ch||y.default.ch,t.fg=t.fg||y.default.fg),t.name||(t.name=y.default.name),t)),this.flags.actor|=n.flags.Actor.IS_PLAYER,this.attributes=new p(t.attributes||{}),this.skills=new v(t.skills||{})}make(t){const e=new y(this);return this.init(e,t),e}}var k=Object.freeze({__proto__:null,Attributes:p,attributes:g,installAttribute:function(t){"string"!=typeof t?(Object.keys(g).forEach((t=>{delete g[t]})),Object.assign(g,t)):g[t]=0},makeAttributes:function(t){return new p(t)},Skills:v,PlayerKind:x,Player:y,make:function(t={}){const e=new x(t);return new y(e)}});const w={};function j(t,e){w[t]=e}function M(t){return w[t]}async function O(t,e){const s=e.dir;if(!t.map||!s)return!1;const i=a.xy.add(t,s),r=t.map.cell(i.x,i.y);return!!r&&(t.avoidsCell(r)?(n.fx.hit(t.map,i,"hit",100,this.layer),!1):(t.map.removeActor(t),t.map.addActor(i.x,i.y,t),!0))}async function A(t,e){if(!t.map)return!1;const s=t.map.itemAt(t.x,t.y);if(!s)return a.message.addAt(t.x,t.y,"Nothing to pickup."),!1;const i=s;if(t.avoidsItem(i))return!1;let n=i.getAction("pickup");return!1===n?(a.message.addAt(t.x,t.y,"You cannot pickup %{the.item}.",{item:s}),!1):"function"==typeof n?n.call(i,t):!!t.canAddItem(i)&&(!!t.map.removeItem(i)&&(t.addItem(i),!0))}j("moveDir",O),j("pickup",A);var E=Object.freeze({__proto__:null,actions:w,install:j,get:M,moveDir:O,pickup:A});var I=Object.freeze({__proto__:null,Game:class{constructor(t){this.running=!1,this.keymap={},this.ui=new a.ui.UI(t),this.makeMap=t.makeMap,this.makePlayer=t.makePlayer,this.startMap=t.startMap,t.keymap&&Object.assign(this.keymap,t.keymap)}async start(){for(this.layer=this.ui.startNewLayer(),this.buffer=this.layer.buffer,this.player=this.makePlayer(),this.map=this.makeMap(0),this.startMap(this.map,this.player),this.running=!0;this.running;)await this.runTurn()}draw(){this.map.needsRedraw&&(this.map.drawInto(this.buffer),this.buffer.render())}finish(){this.running=!1,this.layer.finish()}async runTurn(){const t=this.map.actors.slice();for(let e of t)this.draw(),e===this.player?await this.playerTurn(this.player):await e.act(),await this.animate();this.map.tick(50)}async animate(){if(!this.layer._tweens.length)return;const t=setInterval((()=>{const t=a.io.makeTickEvent(16);this.ui.loop.pushEvent(t)}),16);for(;this.layer._tweens.length;){const t=await this.ui.loop.nextTick();t&&t.dt&&(this.layer._tweens.forEach((e=>e&&e.tick(t.dt))),this.layer._tweens=this.layer._tweens.filter((t=>t&&t.isRunning()))),this.draw()}clearInterval(t)}async playerTurn(t){let e=!1;const s=setInterval((()=>{const t=a.io.makeTickEvent(16);this.ui.loop.pushEvent(t)}),16);for(;!e;){const s=await this.ui.loop.nextEvent(-1);if(s)if(s.type===a.io.KEYPRESS){const i=a.io.handlerFor(s,this.keymap);if(i)if("string"==typeof i){const n=M(i);n&&(n.call(this,t,s),e=!0)}else"function"==typeof i&&(i.call(this,t,s),e=!0)}else s.type===a.io.TICK&&this.layer.tick(s)}clearInterval(s)}}});t.action=E,t.actor=f,t.game=I,t.item=u,t.player=k,Object.defineProperty(t,"__esModule",{value:!0})}));
//# sourceMappingURL=gw-entity.min.js.map
