{"version":3,"file":"gw-entity.min.js","sources":["../js/item/item.js","../js/item/kind.js","../js/actor/pain.js","../js/actor/stat.js","../js/actor/status.js","../js/actor/actor.js","../js/actor/kind.js","../js/player/attribute.js","../js/player/skill.js","../js/player/player.js","../js/player/kind.js","../js/action/action.js","../js/action/moveDir.js","../js/action/pickup.js","../js/game/game.js"],"sourcesContent":["import * as GWM from 'gw-map';\nexport class Item extends GWM.item.Item {\n    constructor(kind) {\n        super(kind);\n    }\n    getAction(name) {\n        const action = this.kind.actions[name];\n        return action;\n    }\n}\n","import * as GWM from 'gw-map';\nimport { Item } from './item';\nexport class ItemKind extends GWM.item.ItemKind {\n    constructor(config) {\n        super(config);\n        this.actions = {};\n        if (config.actions) {\n            Object.entries(config.actions).forEach(([key, value]) => {\n                this.actions[key] = value;\n            });\n        }\n    }\n    make(options) {\n        const item = new Item(this);\n        this.init(item, options);\n        return item;\n    }\n}\n","import * as GWU from 'gw-utils';\nexport class PainMessages {\n    constructor(msgs = []) {\n        this._msgs = [];\n        msgs.forEach((m) => this.add(m));\n    }\n    add(msg) {\n        this._msgs.push(msg);\n        return this;\n    }\n    get(pct, singular = true) {\n        const index = GWU.clamp(Math.floor(pct * this._msgs.length), 0, this._msgs.length - 1);\n        const msg = this._msgs[index];\n        return this._format(msg, singular);\n    }\n    _format(msg, singular = true) {\n        return msg.replace(/\\[(\\w+)\\|?(\\w*)\\]/g, singular ? '$1' : '$2');\n    }\n}\nexport const painMessages = {};\nexport function installPain(id, pain) {\n    if (Array.isArray(pain)) {\n        pain = new PainMessages(pain);\n    }\n    painMessages[id] = pain;\n}\nexport function getPain(id) {\n    const m = painMessages[id];\n    if (!m)\n        throw new Error('No such pain message index: ' + id);\n    return m;\n}\n","import * as GWU from 'gw-utils';\nexport class Stats {\n    constructor(opts = {}) {\n        this._max = {};\n        this._rate = {};\n        this._value = {};\n        this.init(opts);\n    }\n    get(name) {\n        return this._value[name];\n    }\n    max(name) {\n        return this._max[name] || 0;\n    }\n    regen(name) {\n        return this._rate[name] || null;\n    }\n    init(opts) {\n        for (let name in opts) {\n            this.set(name, opts[name]);\n        }\n    }\n    set(name, v, max) {\n        if (typeof v !== 'number') {\n            const r = GWU.range.make(v);\n            v = r.value();\n        }\n        this._value[name] = v;\n        this._max[name] = max || v;\n    }\n    gain(name, amount, allowOver = false) {\n        if (typeof amount !== 'number') {\n            amount = GWU.range.value(amount);\n        }\n        let v = this._value[name] + amount;\n        if (!allowOver) {\n            v = Math.min(v, this._max[name]);\n        }\n        this._value[name] = v;\n    }\n    drain(name, amount) {\n        if (typeof amount !== 'number') {\n            amount = GWU.range.value(amount);\n        }\n        this._value[name] = Math.max(0, this._value[name] - amount);\n    }\n    raiseMax(name, amount, raiseValue = true) {\n        if (typeof amount !== 'number') {\n            amount = GWU.range.value(amount);\n        }\n        this._max[name] += amount;\n        if (raiseValue) {\n            this.gain(name, amount);\n        }\n    }\n    reduceMax(name, amount, lowerValue = false) {\n        if (typeof amount !== 'number') {\n            amount = GWU.range.value(amount);\n        }\n        this._max[name] = Math.max(0, this._max[name] - amount);\n        if (lowerValue) {\n            this.drain(name, amount);\n        }\n    }\n    setRegen(name, turns, count = 1) {\n        const r = (this._rate[name] = this._rate[name] || { elapsed: 0 });\n        r.turns = turns;\n        r.count = count;\n    }\n    regenAll() {\n        for (let name in this._max) {\n            const r = this._rate[name];\n            r.elapsed += 1;\n            if (r.elapsed >= r.turns) {\n                this.gain(name, r.count);\n                r.elapsed -= r.turns;\n            }\n        }\n    }\n    restore(name, value) {\n        if (value === undefined)\n            value = this._max[name];\n        this._value[name] = value;\n    }\n    adjust(name, type, amount) {\n        amount = GWU.range.from(amount);\n        const v = amount.value();\n        const c = this.get(name);\n        if (type === 'inc') {\n            this.gain(name, amount);\n        }\n        else if (type === 'dec') {\n            this.drain(name, amount);\n        }\n        else if (type === 'set') {\n            this.set(name, amount);\n        }\n        else if (type === 'min') {\n            const v = amount.value();\n            if (this.get(name) < v) {\n                this.set(name, v);\n            }\n        }\n        else if (type === 'max') {\n            if (this.get(name) > v) {\n                this.set(name, v);\n            }\n        }\n        else {\n            throw new Error('Invalid stat adjust type: ' + type);\n        }\n        return c !== this.get(name);\n    }\n}\n","import * as GWU from 'gw-utils';\nexport class Status {\n    constructor() {\n        this._set = {};\n        this._time = {};\n        this._count = {};\n        this._done = {};\n        this._value = {};\n        this.changed = null;\n    }\n    clear(name) {\n        this.clearTime(name);\n        this.clearCount(name);\n        this.setOff(name);\n        return this._update(name);\n    }\n    get(name) {\n        return this._value[name] || false;\n    }\n    has(name) {\n        return this._value[name] || false;\n    }\n    _addDone(name, done) {\n        if (done) {\n            if (!this._done[name]) {\n                this._done[name] = done;\n            }\n        }\n    }\n    /**\n     * Sets the count for a status variable.\n     * If setting the count turns on the status (it was off),\n     * then this function returns true.  Otherwise, false.\n     * The done variable is only set if there is no other done function\n     * already for this status.\n     * @param {string} name The name of the status to set.\n     * @param {number} count The count to set.\n     * @param {function} [done] The function to call whenever the count goes to 0.\n     * @returns {boolean} Whether or not setting the count turned the status on.\n     */\n    setCount(name, count, done) {\n        const status = this;\n        status._count[name] = Math.max(count, status._count[name] || 0);\n        this._addDone(name, done);\n        return this._update(name);\n    }\n    /**\n     * Increments the count for the status by the given amount (1=default)\n     * If incrementing the count turns on the status (it was off),\n     * then this function returns true.  Otherwise, false.\n     * The done variable is only set if there is no other done function\n     * already for this status.\n     * @param {string} name The name of the status to set.\n     * @param {number} [count=1] The count to incrmeent.\n     * @param {function} [done] The function to call whenever the count goes to 0.\n     * @returns {boolean} Whether or not incrementing the count turned the status on.\n     */\n    increment(name, count = 1, done) {\n        if (typeof count == 'function') {\n            done = count;\n            count = 1;\n        }\n        const status = this;\n        status._count[name] = (status._count[name] || 0) + count;\n        this._addDone(name, done);\n        return this._update(name);\n    }\n    /**\n     * Decrements the count for the status by the given amount (1=default)\n     * If decrementing the count turns off the status (it was on),\n     * then this function returns true.  Otherwise, false.\n     * Also, if the status is turned off, and a done function was set, then it\n     * is called.\n     * @param {string} name The name of the status to adjust.\n     * @param {number} [count=1] The count to decrement.\n     * @returns {boolean} Whether or not decrementing the count turned the status off.\n     */\n    decrement(name, count = 1) {\n        const status = this;\n        status._count[name] = Math.max(0, (status._count[name] || 0) - count);\n        return this._update(name);\n    }\n    /**\n     * Clears all counts from the given status.\n     * If clearing the count turns off the status (it was on),\n     * then this function returns true.  Otherwise, false.\n     * Also, if the status is turned off, and a done function was set, then it\n     * is called.\n     * @param {string} name The name of the status to adjust.\n     * @returns {boolean} Whether or not decrementing the count turned the status off.\n     */\n    clearCount(name) {\n        const status = this;\n        status._count[name] = 0;\n        return this._update(name);\n    }\n    /**\n     * Turns on the given status.\n     * @param {string} name The status to adjust.\n     * @param {function} [done] The function to call when the status is turned off.\n     * @returns {boolean} True if this turns on the status. (It could be on because of a time or count).\n     */\n    setOn(name, done) {\n        const status = this;\n        status._set[name] = true;\n        this._addDone(name, done);\n        return this._update(name);\n    }\n    /**\n     * Turns off the given status.\n     *\n     * @param {string} name The status to adjust.\n     * @returns {boolean} True if this turns off the status. (It could be on because of a time or count).\n     */\n    setOff(name) {\n        const status = this;\n        status._set[name] = false;\n        return this._update(name);\n    }\n    /**\n     * Sets the time for a status variable.\n     * If setting the time turns on the status (it was off),\n     * then this function returns true.  Otherwise, false.\n     * The done variable is only set if there is no other done function\n     * already for this status.\n     * @param {string} name The name of the status to set.\n     * @param {GWU.range.RangeBase} time The time value to set.\n     * @param {function} [done] The function to call whenever the status goes false.\n     * @returns {boolean} Whether or not setting the time turned the status on.\n     */\n    setTime(name, value, done) {\n        const status = this;\n        // if (value === true) {\n        //   return RUT.Status.setOn(source, name, done);\n        // }\n        value = GWU.range.make(value).value();\n        const current = status._time[name] || 0;\n        status._time[name] = Math.max(value, current);\n        this._addDone(name, done);\n        return this._update(name);\n    }\n    /**\n     * Adds to the time for a status variable.\n     * If adding to the time turns on the status (it was off),\n     * then this function returns true.  Otherwise, false.\n     * The done variable is only set if there is no other done function\n     * already for this status.\n     * @param {string} name The name of the status to set.\n     * @param {GWU.range.RangeBase} time The time value to add.\n     * @param {function} [done] The function to call whenever the status goes false.\n     * @returns {boolean} Whether or not adding the time turned the status on.\n     */\n    addTime(name, value = 1, done) {\n        if (typeof value == 'function') {\n            done = value;\n            value = 1;\n        }\n        const status = this;\n        // if (value === true) {\n        //   return RUT.Status.setOn(source, name, done);\n        // }\n        value = GWU.range.make(value).value();\n        status._time[name] = (status._time[name] || 0) + value;\n        this._addDone(name, done);\n        return this._update(name);\n    }\n    /**\n     * Removes time for a status variable.\n     * If removing to the time turns off the status (it was on),\n     * then this function returns true.  Otherwise, false.\n     * @param {string} name The name of the status to set.\n     * @param {GWU.range.RangeBase} time The time value to remove.\n     * @returns {boolean} Whether or not removing the time turned the status off.\n     */\n    removeTime(name, value = 1) {\n        const status = this;\n        value = GWU.range.make(value).value();\n        status._time[name] = Math.max(0, (status._time[name] || 0) - value);\n        return this._update(name);\n    }\n    /**\n     * Removes all time for a status variable.\n     * If removing to the time turns off the status (it was on),\n     * then this function returns true.  Otherwise, false.\n     * @param {string} name The name of the status to set.\n     * @returns {boolean} Whether or not removing the time turned the status off.\n     */\n    clearTime(name) {\n        const status = this;\n        status._time[name] = 0;\n        return this._update(name);\n    }\n    /**\n     * Removes time for all status variables that have time.\n     * If removing the time turns off any status (it was on),\n     * then this function returns an object with all of those statuses as keys and false as the values.  Otherwise, false.\n     * @param {Status|object} source The object to set the status on.  If object.status is set then that is where the values are updated.\n     * @param {string} name The name of the status to set.\n     * @returns {boolean|object} false or an object with the names of the statuses that were cleared as keys and false as the values.\n     */\n    decayAllTimes(delta = 1) {\n        const status = this;\n        const cleared = {};\n        let noticed = false;\n        for (let name in status._time) {\n            if (this.removeTime(name, delta)) {\n                noticed = true;\n                cleared[name] = false;\n            }\n        }\n        return noticed ? cleared : false;\n    }\n    /**\n     * Updates the value of the status and returns whether or not this change\n     * turned the status on or off (true = change, false = no change)\n     * @param {string} name The name of the status to update\n     * @returns {boolean} True if the value was turned on or off, False otherwise.\n     */\n    _update(name) {\n        const status = this;\n        const rec = this._value;\n        let was = rec[name];\n        let value = (rec[name] =\n            status._set[name] ||\n                status._time[name] > 0 ||\n                status._count[name] > 0 ||\n                false);\n        const doneFn = this._done[name];\n        if (!value && doneFn) {\n            doneFn(this, name);\n            status._done[name] = null;\n        }\n        if (was && !value) {\n            if (this.changed)\n                this.changed(this, name);\n            // console.log('called changed: false');\n            return true;\n        }\n        else if (!was && value) {\n            if (this.changed)\n                this.changed(this, name);\n            // console.log('called changed: true');\n            return true;\n        }\n        return false;\n    }\n}\n","import * as GWM from 'gw-map';\nimport { Stats } from './stat';\nimport { Status } from './status';\nexport class Actor extends GWM.actor.Actor {\n    constructor(kind) {\n        super(kind);\n        this.stats = new Stats();\n        this.status = new Status();\n    }\n    avoidsItem(_item) {\n        return false;\n    }\n    canAddItem(_item) {\n        return false;\n    }\n    addItem(_item) { }\n    async act() {\n        return true;\n    }\n}\n","import * as GWM from 'gw-map';\n// import { Stats } from './stat';\nimport { Actor } from './actor';\nexport class ActorKind extends GWM.actor.ActorKind {\n    constructor(opts) {\n        super(opts);\n        this.stats = opts.stats || {};\n    }\n    make(options) {\n        const actor = new Actor(this);\n        this.init(actor, options);\n        return actor;\n    }\n    init(actor, options = {}) {\n        super.init(actor, options);\n        actor.stats.init(this.stats);\n    }\n}\n","/*\n    Attributes\n    ========================\n\n    To configure attributes, set the defaults:\n\n    Attribute.install(')\n\n    const attr = new Attributes(10);\n\n    attr.set('str', 10);\n    attr.set('dex', 10);\n    ...\n    attr.set('chr', 10);\n\n    // to get the current value\n    attr.get('str');\n\n    // To raise an attribute permanently\n    attr.gain('chr', 1);\n\n    // To raise an attribute temporarily\n    attr.gain('chr', 1, false);\n\n    // To lower an attribute permanently\n    attr.drain('chr', 1, true);\n\n    // to lower an attribute temporarily\n    attr.drain('chr', 1);\n\n    // to restore (remove) all temporary changes\n    attr.restore();\n\n    // to add a temporary change that can be removed by itself\n    attr.addBonus('str', 1);\n\n    // to remove the bonus\n    attr.clearBonus('str', 1);\n\n    // adjustments (bonuses) are also possible via:\n    attr.adjust('str', { bonus: 1 });\n\n    // But adjustments can also set the\n    attr.adjust('str', { fixed: 14 });      // temporarily sets base\n    attr.adjust('str', { base: 21 });       // resets the base\n    attr.adjust('str', { restore: true });  // removes all bonuses/penalties\n    attr.adjust('str', { min: 10 });        // limits value\n    attr.adjust('str', { max: 30 });        // limits value\n    attr.adjust('str', { sustain: true });  // turns off lowering values\n*/\nexport class Attributes {\n    constructor(baseValues) {\n        this._base = {};\n        this._max = {};\n        this._bonus = {};\n        this._sustain = {};\n        this._value = {};\n        this.changed = null;\n        this.init(baseValues);\n    }\n    init(baseValues) {\n        for (let k in attributes) {\n            const v = typeof baseValues === 'number' ? baseValues : attributes[k];\n            this.set(k, v);\n        }\n        if (typeof baseValues !== 'number') {\n            for (let k in baseValues) {\n                this.set(k, baseValues[k]);\n            }\n        }\n    }\n    forEach(fn) {\n        Object.keys(attributes).forEach((k) => fn(this.get(k)));\n    }\n    // modifier(name: string) {\n    //     return Math.floor((this.get(name) - 10) / 2);\n    // }\n    get(name) {\n        return this._value[name] || 0;\n    }\n    set(name, value = 0) {\n        this._value[name] = value;\n        this._base[name] = value;\n        this._max[name] = value;\n        this._bonus[name] = [];\n        return value;\n    }\n    base(name) {\n        return this._base[name] || 0;\n    }\n    max(name) {\n        return this._max[name] || 0;\n    }\n    sustain(name) {\n        return this._sustain[name] || false;\n    }\n    gain(name, delta, raiseMax = true) {\n        if (delta < 0 && this._sustain[name])\n            return 0;\n        this._base[name] += delta;\n        if (raiseMax && this._base[name] > this._max[name]) {\n            this._max[name] = this._base[name];\n        }\n        let old = this.get(name);\n        return this._calcValue(name) - old;\n    }\n    drain(name, loss, lowerMax = false) {\n        if (loss < 0)\n            loss = -loss;\n        const changed = this.gain(name, -loss, false);\n        if (changed && lowerMax) {\n            this._max[name] = this._base[name];\n        }\n        return changed;\n    }\n    restore(name) {\n        this._base[name] = this._max[name];\n        let old = this.get(name);\n        return this._calcValue(name) - old;\n    }\n    addBonus(name, bonus) {\n        return this._addBonus(name, { bonus });\n    }\n    _addBonus(name, bonus) {\n        if (typeof bonus === 'number')\n            bonus = { bonus };\n        if (this._value[name] === undefined) {\n            this.set(name, 0);\n        }\n        this._bonus[name].push(bonus);\n        let old = this.get(name);\n        return this._calcValue(name) - old;\n    }\n    clearBonus(name, bonus) {\n        return this._clearBonus(name, { bonus });\n    }\n    _clearBonus(name, bonus) {\n        if (typeof bonus === 'number')\n            bonus = { bonus };\n        let arr = this._bonus[name] || [];\n        let key = JSON.stringify(bonus);\n        let index = arr.findIndex((o) => {\n            return JSON.stringify(o) == key;\n        });\n        if (index > -1) {\n            arr.splice(index, 1);\n            let old = this.get(name);\n            return this._calcValue(name) - old;\n        }\n        return 0;\n    }\n    _calcValue(name) {\n        let allAdjustments = {};\n        this._bonus[name].forEach((adj) => this._applyAdjustment(allAdjustments, adj));\n        this._sustain[name] = allAdjustments.sustain || false;\n        let value = this._base[name] || 0;\n        if (allAdjustments.fixed !== undefined) {\n            value = allAdjustments.fixed;\n        }\n        else {\n            value += allAdjustments.bonus || 0;\n            if (allAdjustments.min !== undefined) {\n                value = Math.max(allAdjustments.min, value);\n            }\n            if (allAdjustments.max !== undefined) {\n                value = Math.min(allAdjustments.max, value);\n            }\n        }\n        return (this._value[name] = value);\n    }\n    adjust(name, adj) {\n        let delta = undefined;\n        if (typeof adj === 'number') {\n            adj = { bonus: adj };\n        }\n        if (adj.base) {\n            delta = this.gain(name, adj.base);\n        }\n        else if (adj.restore) {\n            delta = this.restore(name);\n            if (delta == 0)\n                delta = undefined;\n        }\n        else {\n            delta = this._addBonus(name, adj);\n        }\n        if (this.changed && delta !== undefined)\n            this.changed(this, name);\n        return delta;\n    }\n    clearAdjustment(name, adj) {\n        let delta = undefined;\n        if (typeof adj === 'number') {\n            adj = { bonus: adj };\n        }\n        if (adj.base) {\n            delta = this.drain(name, adj.base, true);\n        }\n        else if (adj.restore) {\n            // do nothing...\n        }\n        else {\n            delta = this._clearBonus(name, adj);\n        }\n        if (this.changed && delta !== undefined)\n            this.changed(this, name);\n        return delta;\n    }\n    _applyAdjustment(total, opts) {\n        if (opts.bonus) {\n            total.bonus = (total.bonus || 0) + opts.bonus;\n        }\n        if (opts.fixed !== undefined) {\n            total.fixed = Math.max(total.fixed || 0, opts.fixed);\n        }\n        if (opts.min !== undefined) {\n            total.min = Math.max(total.min || 0, opts.min);\n        }\n        if (opts.max !== undefined) {\n            total.max = Math.max(total.max || 0, opts.max);\n        }\n        if (opts.sustain !== undefined) {\n            total.sustain = opts.sustain;\n        }\n    }\n}\nexport const attributes = {};\nexport function installAttribute(attr) {\n    if (typeof attr === 'string') {\n        attributes[attr] = 0;\n        return;\n    }\n    // clear existing\n    Object.keys(attributes).forEach((k) => {\n        delete attributes[k];\n    });\n    Object.assign(attributes, attr);\n}\nexport function makeAttributes(defaults) {\n    return new Attributes(defaults);\n}\n/*\nfunction adjust(being, ...args) {\n    let adj;\n    if (args.length == 1 && typeof args[0] == 'number') {\n        adj = RUT.Attributes.map((key) => {\n            return { name: key, bonus: args[0] };\n        });\n    } else {\n        adj = normalize_adjustment(args);\n    }\n\n    let results = adj.reduce((out, a) => {\n        let delta = undefined;\n        if (a.base) {\n            delta = being.attributes.addBase(a.name, a.base);\n        } else if (a.restore) {\n            delta = being.attributes.restoreBase(a.name);\n            if (delta == 0) delta = undefined;\n        } else {\n            delta = being.attributes.addBonus(a.name, a);\n        }\n        if (delta !== undefined) {\n            out[a.name] = delta;\n        }\n        return out;\n    }, {});\n    being.changed({ attributes: results });\n\n    return results;\n};\n\n function clearAdjustment(being, ...args) {\n    let adj;\n    if (args.length == 1 && typeof args[0] == 'number') {\n        adj = RUT.Attributes.map((key) => {\n            return { name: key, bonus: args[0] };\n        });\n    } else {\n        adj = normalize_adjustment(args);\n    }\n\n    let results = adj.reduce((out, a) => {\n        let delta = 0;\n        delta += being.attributes.clearBonus(a.name, a);\n\n        out[a.name] = delta;\n        return out;\n    }, {});\n    being.changed({ attributes: results });\n    return results;\n};\n\nRUT.Attribute.rollAttributes = function (opts = {}) {\n    let dice = [];\n    let total = 0;\n\n    if (RUT.Calc.isValue(opts)) opts = { value: opts };\n    Object.defaults(opts, RUT.Config.Attribute.rollAttributes);\n\n    let attributes = RUT.Config.Attributes;\n\n    let min_average = Math.max(opts.min_average - 5, 0);\n    let max_average = Math.min(opts.max_average - 5, RUT.Config.ATTRIBUTE_MAX);\n\n    let min_total = min_average * attributes.length;\n    let max_total = max_average * attributes.length;\n\n    do {\n        total = 0;\n        dice = [];\n        for (let i = 0; i < 18; ++i) {\n            dice.push(RUT.RNG.rollDie(3 + (i % 3)));\n            total += dice[i];\n        }\n    } while (total <= min_total || total > max_total);\n\n    let values = attributes.reduce((out, name, i) => {\n        let index = 3 * i;\n        let value = 5 + dice[index] + dice[index + 1] + dice[index + 2];\n        if (opts.value) {\n            value = RUT.Calc.calc(opts.value);\n        } else if (opts[name]) {\n            value = RUT.Calc.calc(opts[name]);\n        }\n        out[name] = value;\n        return out;\n    }, {});\n    return values;\n};\nRUT.Config.Attribute.rollAttributes = { min_average: 11, max_average: 14 };\n*/\n/*\nexport function normalize_adjustment(args: ) {\n    if (args.length == 3) {\n        let opts = args[2];\n        if (RUT.Calc.isValue(opts)) {\n            opts = { bonus: opts };\n        }\n        let name = `${args[0]}.${args[1]}`;\n        return [Object.assign({ name }, opts)];\n    }\n    if (args.length == 2) {\n        let opts = args[1];\n        if (opts === true || opts === false) {\n            opts = { has: opts };\n        } else if (RUT.Calc.isValue(opts)) {\n            opts = { bonus: opts };\n        }\n        return [Object.assign({ name: args[0] }, opts)];\n    }\n\n    let opts = args[0];\n    if (opts.name) {\n        return [opts];\n    }\n    if (opts.attribute) {\n        opts.name = opts.attribute;\n        return [opts];\n    }\n    if (opts.restore) {\n        if (opts.restore == 'all') {\n            return RUT.Attributes.map((a) => {\n                return { name: a, restore: true };\n            });\n        }\n        return [{ name: opts.restore, restore: true }];\n    }\n    if (opts.skill) {\n        opts.name = opts.skill;\n        return [opts];\n    }\n    if (opts.stat) {\n        opts.name = opts.stat;\n        return [opts];\n    }\n    if (opts.save) {\n        opts.name = opts.save;\n        return [opts];\n    }\n    // if (opts.saves) {\n    //   opts.name = opts.saves;\n    //   return [opts];\n    // }\n    if (opts.ability) {\n        opts.name = opts.ability;\n        return [opts];\n    }\n\n    // now we assume that each key is for a separate skill...\n    return Object.keys(opts).reduce((out, key) => {\n        let opt = opts[key];\n        if (key == 'reset' || key == 'restore') {\n            if (typeof opt == 'string') opt = [opt];\n            opt.forEach((a) => {\n                out.push({ name: a, restore: true });\n            });\n        } else {\n            if (typeof opt == 'number' || Array.isArray(opt)) {\n                opt = { bonus: opt };\n            } else if (opt === true || opt === false) {\n                opt = { has: opt };\n            } else if (opt == 'reset' || opt == 'restore') {\n                opt = { restore: true };\n            } else if (opt == 'sustain') {\n                opt = { sustain: true };\n            }\n            out.push(Object.assign({ name: key }, opt));\n        }\n        return out;\n    }, []);\n}\n*/\n","/*\nSkills\n\nSkills generally fall into 2 categories - binary and progressive.\n\n\n// Create a skills object\nconst skills = new Skills();\n\n// set skills\nskills.set('diving', true); // = { has: true, level: 0 }\nskills.set('diving', 10); // = { has: true, level: 10 }\n\nskills.remove('diving'); // {}\n\n// adjustments\nskills.adjust('diving', { bonus: 1 });\nskills.adjust('diving', { disadvantage: true });\nskills.adjust('diving', { advantage: 3 });\nskills.adjust('diving', { fixed: 10 });\nskills.adjust('diving', { critical: 5 });\n\n\n\n\n\n*/\nclass Skill {\n    constructor(name) {\n        this.name = name;\n    }\n    get has() {\n        return this._bool('_has');\n    }\n    get level() {\n        return this._int('_level');\n    }\n    get disadvantage() {\n        return this._bool('_disadvantage');\n    }\n    get advantage() {\n        return this._bool('_advantage');\n    }\n    get fixed() {\n        return this._int('_fixed');\n    }\n    get bonus() {\n        const b = this._int('_bonus') || 0;\n        if (!this._parent)\n            return b;\n        return b + this._parent.bonus;\n    }\n    get succeed() {\n        return this._bool('_succeed');\n    }\n    get fail() {\n        return this._bool('_fail');\n    }\n    set(value) {\n        if (value === false) {\n            this._has = false;\n            this._level = 0;\n        }\n        else {\n            this._has = true;\n            this._level = value === true ? 0 : value;\n        }\n    }\n    _value(name) {\n        if (this[name] !== undefined) {\n            // @ts-ignore\n            return this[name];\n        }\n        if (this._parent) {\n            // @ts-ignore\n            return this._parent._value(name);\n        }\n        return undefined;\n    }\n    _bool(name) {\n        return !!this._value(name);\n    }\n    _int(name) {\n        return this._value(name);\n    }\n    adjust(adj) {\n        Object.entries(adj).forEach(([key, value]) => {\n            key = '_' + key;\n            if (value === undefined)\n                return;\n            if (key === '_fixed') {\n                if (typeof value !== 'number') {\n                    throw new Error('fixed skill adjustment must be a number.');\n                }\n                value = Math.max(value, this._fixed || 0);\n            }\n            else if (key === '_bonus') {\n                if (typeof value !== 'number') {\n                    throw new Error('fixed skill adjustment must be a number.');\n                }\n                value = value + (this._bonus || 0);\n            }\n            // @ts-ignore\n            this[key] = value;\n        });\n    }\n    clear(adj) {\n        Object.keys(adj).forEach((key) => {\n            key = '_' + key;\n            // @ts-ignore\n            if (this[key] !== undefined) {\n                // @ts-ignore\n                this[key] = undefined;\n            }\n        });\n    }\n}\nexport class Skills {\n    constructor(vals = {}) {\n        this._skills = {};\n        Object.entries(vals).forEach(([key, value]) => {\n            this.set(key, value);\n        });\n    }\n    set(name, value) {\n        const s = this.get(name);\n        s.set(value);\n        return s;\n    }\n    get(name) {\n        let s = this._skills[name];\n        if (s)\n            return s;\n        s = this._skills[name] = new Skill(name);\n        const index = name.lastIndexOf('.');\n        if (index > 0) {\n            s._parent = this.get(name.substring(0, index));\n        }\n        else {\n            s.set(false);\n        }\n        return s;\n    }\n    adjust(name, adj) {\n        if (typeof adj === 'number') {\n            adj = { bonus: adj };\n        }\n        let s = this.get(name);\n        s.adjust(adj);\n        return s;\n    }\n}\n","// import * as GWM from 'gw-map';\nimport { Actor } from '../actor';\nimport { PlayerKind } from './kind';\nexport class Player extends Actor {\n    constructor(kind) {\n        super(kind);\n    }\n}\nPlayer.default = {\n    ch: '@',\n    fg: 'white',\n    name: 'You',\n};\nexport function make(options = {}) {\n    const kind = new PlayerKind(options);\n    return new Player(kind);\n}\n","import * as GWM from 'gw-map';\nimport * as Actor from '../actor';\nimport * as Skills from './skill';\nimport * as Attributes from './attribute';\nimport { Player } from './player';\nexport class PlayerKind extends Actor.ActorKind {\n    constructor(opts = {}) {\n        super((() => {\n            if (!opts.sprite) {\n                opts.ch = opts.ch || Player.default.ch;\n                opts.fg = opts.fg || Player.default.fg;\n            }\n            if (!opts.name) {\n                opts.name = Player.default.name;\n            }\n            return opts;\n        })());\n        this.flags.actor |= GWM.flags.Actor.IS_PLAYER;\n        this.attributes = new Attributes.Attributes(opts.attributes || {});\n        this.skills = new Skills.Skills(opts.skills || {});\n    }\n    make(options) {\n        const actor = new Player(this);\n        this.init(actor, options);\n        return actor;\n    }\n}\n","export const actions = {};\nexport function install(name, fn) {\n    actions[name] = fn;\n}\nexport function get(name) {\n    return actions[name];\n}\n","import * as GWU from 'gw-utils';\nimport * as GWM from 'gw-map';\nimport { install } from './action';\n// COMMANDS\n// this === GAME\nexport async function moveDir(actor, e) {\n    const dir = e.dir;\n    if (!actor.map || !dir)\n        return false;\n    const newPos = GWU.xy.add(actor, dir);\n    const cell = actor.map.cell(newPos.x, newPos.y);\n    if (!cell)\n        return false;\n    if (actor.avoidsCell(cell)) {\n        GWM.fx.hit(actor.map, newPos, 'hit', 100, this.layer);\n        // todo - should this cost a turn?  Or part of one?\n        return false;\n    }\n    actor.map.removeActor(actor);\n    actor.map.addActor(newPos.x, newPos.y, actor);\n    return true;\n}\ninstall('moveDir', moveDir);\n","import * as GWU from 'gw-utils';\nimport { install } from './action';\nexport async function pickup(actor, _ev) {\n    if (!actor.map)\n        return false;\n    const item = actor.map.itemAt(actor.x, actor.y);\n    if (!item) {\n        GWU.message.addAt(actor.x, actor.y, 'Nothing to pickup.');\n        return false;\n    }\n    const myItem = item;\n    if (actor.avoidsItem(myItem))\n        return false;\n    let action = myItem.getAction('pickup');\n    if (action === false) {\n        GWU.message.addAt(actor.x, actor.y, 'You cannot pickup %{the.item}.', {\n            item,\n        });\n        return false;\n    }\n    else if (typeof action === 'function') {\n        // You have to do everything\n        return action.call(myItem, actor);\n    }\n    // logs error messages\n    if (!actor.canAddItem(myItem)) {\n        return false;\n    }\n    if (!actor.map.removeItem(myItem)) {\n        return false;\n    }\n    actor.addItem(myItem);\n    return true;\n}\ninstall('pickup', pickup);\n","import * as GWU from 'gw-utils';\nimport * as Action from '../action';\nexport class Game {\n    constructor(opts) {\n        this.running = false;\n        this.keymap = {};\n        this.ui = new GWU.ui.UI(opts);\n        this.makeMap = opts.makeMap;\n        this.makePlayer = opts.makePlayer;\n        this.startMap = opts.startMap;\n        if (opts.keymap) {\n            Object.assign(this.keymap, opts.keymap);\n        }\n    }\n    async start() {\n        this.layer = this.ui.startNewLayer();\n        this.buffer = this.layer.buffer;\n        this.player = this.makePlayer();\n        this.map = this.makeMap(0);\n        this.startMap(this.map, this.player);\n        this.running = true;\n        while (this.running) {\n            await this.runTurn();\n        }\n    }\n    draw() {\n        if (this.map.needsRedraw) {\n            this.map.drawInto(this.buffer);\n            this.buffer.render();\n        }\n    }\n    finish() {\n        this.running = false;\n        this.layer.finish();\n    }\n    async runTurn() {\n        const actors = this.map.actors.slice();\n        for (let actor of actors) {\n            this.draw();\n            if (actor === this.player) {\n                await this.playerTurn(this.player);\n            }\n            else {\n                await actor.act();\n            }\n            await this.animate();\n        }\n        this.map.tick(50); // turn time\n    }\n    async animate() {\n        if (!this.layer._tweens.length)\n            return;\n        const timer = setInterval(() => {\n            const tick = GWU.io.makeTickEvent(16);\n            this.ui.loop.pushEvent(tick);\n        }, 16);\n        while (this.layer._tweens.length) {\n            const ev = await this.ui.loop.nextTick();\n            if (ev && ev.dt) {\n                this.layer._tweens.forEach((a) => a && a.tick(ev.dt));\n                this.layer._tweens = this.layer._tweens.filter((a) => a && a.isRunning());\n            }\n            this.draw();\n        }\n        clearInterval(timer);\n    }\n    async playerTurn(player) {\n        let done = false;\n        const timer = setInterval(() => {\n            const tick = GWU.io.makeTickEvent(16);\n            this.ui.loop.pushEvent(tick);\n        }, 16);\n        while (!done) {\n            const ev = await this.ui.loop.nextEvent(-1);\n            if (ev) {\n                if (ev.type === GWU.io.KEYPRESS) {\n                    const handler = GWU.io.handlerFor(ev, this.keymap);\n                    if (handler) {\n                        if (typeof handler === 'string') {\n                            const action = Action.get(handler);\n                            if (action) {\n                                action.call(this, player, ev);\n                                done = true;\n                            }\n                        }\n                        else if (typeof handler === 'function') {\n                            handler.call(this, player, ev);\n                            done = true;\n                        }\n                    }\n                }\n                else if (ev.type === GWU.io.TICK) {\n                    this.layer.tick(ev); // timeouts\n                }\n            }\n        }\n        clearInterval(timer);\n    }\n}\n"],"names":["Item","GWM","item","constructor","kind","super","getAction","name","this","actions","ItemKind","config","Object","entries","forEach","key","value","make","options","init","PainMessages","msgs","_msgs","m","add","msg","push","get","pct","singular","index","GWU","clamp","Math","floor","length","_format","replace","painMessages","Stats","opts","_max","_rate","_value","max","regen","set","v","range","gain","amount","allowOver","min","drain","raiseMax","raiseValue","reduceMax","lowerValue","setRegen","turns","count","r","elapsed","regenAll","restore","undefined","adjust","type","from","c","Error","Status","_set","_time","_count","_done","changed","clear","clearTime","clearCount","setOff","_update","has","_addDone","done","setCount","increment","decrement","setOn","setTime","current","addTime","removeTime","decayAllTimes","delta","status","cleared","noticed","rec","was","doneFn","Actor","actor","stats","avoidsItem","_item","canAddItem","addItem","async","ActorKind","id","pain","Array","isArray","Attributes","baseValues","_base","_bonus","_sustain","k","attributes","fn","keys","base","sustain","old","_calcValue","loss","lowerMax","addBonus","bonus","_addBonus","clearBonus","_clearBonus","arr","JSON","stringify","findIndex","o","splice","allAdjustments","adj","_applyAdjustment","fixed","clearAdjustment","total","Skill","_bool","level","_int","disadvantage","advantage","b","_parent","succeed","fail","_has","_level","_fixed","Skills","vals","_skills","s","lastIndexOf","substring","Player","default","ch","fg","PlayerKind","Actor.ActorKind","sprite","flags","IS_PLAYER","Attributes.Attributes","skills","Skills.Skills","attr","assign","defaults","install","moveDir","e","dir","map","newPos","xy","cell","x","y","avoidsCell","fx","hit","layer","removeActor","addActor","pickup","_ev","itemAt","message","addAt","myItem","action","call","removeItem","running","keymap","ui","UI","makeMap","makePlayer","startMap","startNewLayer","buffer","player","runTurn","draw","needsRedraw","drawInto","render","finish","actors","slice","playerTurn","act","animate","tick","_tweens","timer","setInterval","io","makeTickEvent","loop","pushEvent","ev","nextTick","dt","a","filter","isRunning","clearInterval","nextEvent","KEYPRESS","handler","handlerFor","Action.get","TICK"],"mappings":"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"}